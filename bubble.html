<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Droplet Splitting</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: relative;
            background: linear-gradient(45deg, #001428, #002952, #003973, #004c94);
            background-size: 400% 400%;
            animation: gradientAnimation 30s ease infinite;
        }
        
        @keyframes gradientAnimation {
            0% { background-position: 0% 50%; }
            25% { background-position: 50% 100%; }
            50% { background-position: 100% 50%; }
            75% { background-position: 50% 0%; }
            100% { background-position: 0% 50%; }
        }
        
        /* Ocean floor */
        body::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 15%;
            background: linear-gradient(to top, rgba(0, 57, 115, 0.5), transparent);
            z-index: -3;
        }
        
        /* Water bubbles background effect */
        .bubble {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.05));
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3), inset 0 0 10px rgba(255, 255, 255, 0.2);
            z-index: -1;
            animation: none; /* We'll apply animation with JavaScript */
        }
        
        .bubble::after {
            content: '';
            position: absolute;
            top: 15%;
            left: 15%;
            width: 25%;
            height: 25%;
            background-color: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
        }
        
        /* Removed light rays as requested */

        .droplet {
            position: absolute;
            background: radial-gradient(circle at 30% 30%, #5adbff, #026fb3);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.4), inset 0 0 20px rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            animation: pulsate 2s ease-in-out infinite alternate;
        }
        
        .floating-droplet {
            animation: pulsate 2s ease-in-out infinite alternate;
        }
        
        .float-path-1 {
            animation: float-path-1 15s linear infinite;
        }
        
        .float-path-2 {
            animation: float-path-2 18s linear infinite;
        }
        
        .float-path-3 {
            animation: float-path-3 20s linear infinite;
        }
        
        /* Floating animations with constrained movement to stay within viewport */
        @keyframes float-path-1 {
            0% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(100px, -75px) rotate(90deg); }
            50% { transform: translate(150px, 0) rotate(180deg); }
            75% { transform: translate(75px, 100px) rotate(270deg); }
            100% { transform: translate(0, 0) rotate(360deg); }
        }
        
        @keyframes float-path-2 {
            0% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(-75px, -100px) rotate(120deg); }
            66% { transform: translate(75px, -100px) rotate(240deg); }
            100% { transform: translate(0, 0) rotate(360deg); }
        }
        
        @keyframes float-path-3 {
            0% { transform: translate(0, 0) rotate(0deg); }
            20% { transform: translate(75px, -50px) rotate(72deg); }
            40% { transform: translate(100px, 25px) rotate(144deg); }
            60% { transform: translate(75px, 100px) rotate(216deg); }
            80% { transform: translate(-25px, 50px) rotate(288deg); }
            100% { transform: translate(0, 0) rotate(360deg); }
        }
        
        @keyframes pulsate {
            0% { transform: scale(1); box-shadow: 0 0 15px rgba(255, 255, 255, 0.4), inset 0 0 20px rgba(255, 255, 255, 0.2); }
            100% { transform: scale(1.05); box-shadow: 0 0 20px rgba(255, 255, 255, 0.6), inset 0 0 30px rgba(255, 255, 255, 0.3); }
        }

        .droplet:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.7), inset 0 0 30px rgba(255, 255, 255, 0.4);
        }

        .droplet::after {
            content: '';
            position: absolute;
            top: 10%;
            left: 20%;
            width: 30%;
            height: 30%;
            background-color: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            animation: shimmer 3s infinite linear;
        }
        
        @keyframes shimmer {
            0% { opacity: 0.4; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
            100% { opacity: 0.4; transform: scale(1); }
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.3);
            transform: scale(0);
            animation: ripple-effect 0.8s cubic-bezier(0.22, 0.61, 0.36, 1);
            z-index: 5;
        }

        @keyframes ripple-effect {
            0% { transform: scale(0); opacity: 0.7; }
            50% { opacity: 0.5; }
            100% { transform: scale(3); opacity: 0; }
        }
        
        .splash {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.6);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            z-index: 4;
        }
        
        .slice-line {
            position: absolute;
            height: 2px;
            background: white;
            transform-origin: left center;
            z-index: 10;
            box-shadow: 0 0 8px 1px rgba(255, 255, 255, 0.8);
            animation: slice-animation 0.3s ease-out forwards;
        }
        
        @keyframes slice-animation {
            0% { width: 0; opacity: 1; }
            100% { width: 100px; opacity: 0.2; }
        }
        
        .droplet-half {
            position: absolute;
            background: radial-gradient(circle at 30% 30%, #5adbff, #026fb3);
            overflow: hidden;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.4), inset 0 0 20px rgba(255, 255, 255, 0.2);
            z-index: 3;
        }
        
        .top-half {
            border-radius: 50% 50% 0 0;
            animation: top-half-animation 0.4s ease-out forwards;
        }
        
        .bottom-half {
            border-radius: 0 0 50% 50%;
            animation: bottom-half-animation 0.4s ease-out forwards;
        }
        
        @keyframes top-half-animation {
            0% { transform: translateY(0); }
            100% { transform: translateY(-20px) rotate(-5deg); opacity: 0; }
        }
        
        @keyframes bottom-half-animation {
            0% { transform: translateY(0); }
            100% { transform: translateY(20px) rotate(5deg); opacity: 0; }
        }
    </style>
</head>
<body>
    <script>
        // Declare bubbles array in global scope
        let bubbles = [];
        
        // Handle window resize to keep elements within bounds
        function handleWindowResize() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Adjust bubbles to stay within new window dimensions
            if (bubbles && bubbles.length) {
                bubbles.forEach(bubble => {
                    // Keep bubbles within horizontal boundaries
                    if (bubble.x < 0) {
                        bubble.x = 10;
                    } else if (bubble.x > windowWidth - bubble.size) {
                        bubble.x = windowWidth - bubble.size - 10;
                    }
                    
                    // Keep bubbles within vertical boundaries
                    if (bubble.y < 0) {
                        bubble.y = 10;
                    } else if (bubble.y > windowHeight) {
                        bubble.y = windowHeight - bubble.size - 10;
                    }
                });
            }
            
            // Adjust floating droplets to stay within new window dimensions
            document.querySelectorAll('.floating-droplet').forEach(droplet => {
                const rect = droplet.getBoundingClientRect();
                const size = rect.width;
                
                // Get current position from transform
                let transform = droplet.style.transform;
                let match = transform.match(/translate\(([^,]+)px,\s*([^)]+)px\)/i);
                
                if (match) {
                    let x = parseFloat(match[1]);
                    let y = parseFloat(match[2]);
                    
                    // Adjust position if needed
                    const padding = Math.max(size * 2, 100);
                    
                    if (x < padding) x = padding;
                    if (x > windowWidth - padding) x = windowWidth - padding;
                    if (y < padding) y = padding;
                    if (y > windowHeight - padding) y = windowHeight - padding;
                    
                    // Apply adjusted position
                    droplet.style.transform = `translate(${x}px, ${y}px)`;
                }
            });
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            // Create background bubbles
            createBubbles();
            
            // Add window resize event listener to handle responsive behavior
            window.addEventListener('resize', handleWindowResize);
            
            // Initial droplet size and position - increased for larger droplets
            const initialSize = 150;
            const centerX = window.innerWidth / 2 - initialSize / 2;
            const centerY = window.innerHeight / 2 - initialSize / 2;
            
            // Create the first droplet
            createDroplet(centerX, centerY, initialSize, false);
            
            // Function to create background bubbles
            function createBubbles() {
                const bubbleCount = 50; // Increased bubble count
                // Clear existing bubbles if any
                bubbles = [];
                
                for (let i = 0; i < bubbleCount; i++) {
                    const bubble = document.createElement('div');
                    bubble.className = 'bubble';
                    
                    // Random size
                    const size = 15 + Math.random() * 70;
                    bubble.style.width = `${size}px`;
                    bubble.style.height = `${size}px`;
                    
                    // Random position
                    const posX = Math.random() * window.innerWidth;
                    const posY = window.innerHeight + Math.random() * 500; // Start below the screen
                    
                    // Store bubble properties for animation
                    const bubbleObj = {
                        element: bubble,
                        x: posX,
                        y: posY,
                        speed: 0.5 + Math.random() * 2,
                        oscillationSpeed: 0.5 + Math.random() * 2,
                        oscillationDistance: 30 + Math.random() * 50,
                        size: size,
                        rotation: 0,
                        rotationSpeed: Math.random() * 0.02,
                        opacity: 0.1 + Math.random() * 0.5
                    };
                    
                    // Set initial position
                    bubble.style.left = `${bubbleObj.x}px`;
                    bubble.style.top = `${bubbleObj.y}px`;
                    bubble.style.opacity = '0';
                    
                    document.body.appendChild(bubble);
                    bubbles.push(bubbleObj);
                }
                
                // Animate bubbles
                function animateBubbles() {
                    // Get current window dimensions
                    const windowWidth = window.innerWidth;
                    const windowHeight = window.innerHeight;
                    
                    bubbles.forEach(bubble => {
                        // Update position
                        bubble.y -= bubble.speed;
                        bubble.x += Math.sin(Date.now() / 1000 * bubble.oscillationSpeed) * 0.5;
                        bubble.rotation += bubble.rotationSpeed;
                        
                        // Keep bubbles within horizontal boundaries
                        if (bubble.x < -bubble.size) {
                            bubble.x = -bubble.size / 2;
                        } else if (bubble.x > windowWidth - bubble.size / 2) {
                            bubble.x = windowWidth - bubble.size / 2;
                        }
                        
                        // Reset if off screen (top)
                        if (bubble.y < -bubble.size * 2) {
                            bubble.y = windowHeight + bubble.size;
                            bubble.x = Math.random() * (windowWidth - bubble.size);
                            bubble.opacity = 0.1 + Math.random() * 0.5;
                        }
                        
                        // Calculate opacity based on position
                        let currentOpacity = bubble.opacity;
                        if (bubble.y > windowHeight - 100) {
                            // Fade in
                            currentOpacity = bubble.opacity * (1 - (bubble.y - (windowHeight - 100)) / 100);
                        } else if (bubble.y < 100) {
                            // Fade out
                            currentOpacity = bubble.opacity * (bubble.y / 100);
                        }
                        
                        // Apply new position and rotation
                        bubble.element.style.transform = `translate(${bubble.x}px, ${bubble.y}px) rotate(${bubble.rotation}rad)`;
                        bubble.element.style.opacity = currentOpacity;
                    });
                    
                    requestAnimationFrame(animateBubbles);
                }
                
                // Start animation
                animateBubbles();
            }
            
            // Light rays function removed as requested
            
            // Function to create a droplet
            function createDroplet(x, y, size, isFloating = true) {
                const droplet = document.createElement('div');
                droplet.className = 'droplet';
                
                // Add floating class and random path animation if it's a floating droplet
                if (isFloating) {
                    droplet.classList.add('floating-droplet');
                    
                    // Randomly select one of the three float paths
                    const pathNumber = Math.floor(Math.random() * 3) + 1;
                    droplet.classList.add(`float-path-${pathNumber}`);
                }
                
                droplet.style.width = `${size}px`;
                droplet.style.height = `${size}px`;
                droplet.style.left = `${x}px`;
                droplet.style.top = `${y}px`;
                
                // Add click event to split the droplet
                droplet.addEventListener('click', function(e) {
                    // Get droplet position and dimensions
                    const rect = this.getBoundingClientRect();
                    const dropletCenterX = rect.left + rect.width / 2;
                    const dropletCenterY = rect.top + rect.height / 2;
                    
                    // Create slicing effect
                    createSliceEffect(e.clientX, e.clientY, rect.width * 1.5, this);
                    
                    // Create ripple effect
                    createRippleEffect(e.clientX, e.clientY);
                    
                    // Create splash particles
                    createSplashEffect(e.clientX, e.clientY);
                    
                    // Create droplet halves for slicing animation
                    createDropletHalves(rect, size);
                    
                    // Hide the original droplet
                    this.style.opacity = '0';
                    
                    // Calculate new size for child droplets - using a larger factor to keep split bubbles bigger
                    const newSize = size * 0.85;
                    
                    // Delay the split to show animation
                    setTimeout(() => {
                        // Remove the clicked droplet
                        this.remove();
                        
                        // Only continue splitting if droplets are still visible and not too small
                        if (newSize > 15) {
                            // Create two new droplets with animation and floating effect
                            // Use random positions across the screen but ensure they stay within safe boundaries
                            const screenWidth = window.innerWidth;
                            const screenHeight = window.innerHeight;
                            
                            // Add padding to ensure droplets don't float too close to the edge
                            const padding = Math.max(newSize * 2, 150); // Larger padding based on animation paths
                            
                            // Calculate random positions within screen bounds with padding
                            const randomX1 = padding + Math.random() * (screenWidth - padding * 2);
                            const randomY1 = padding + Math.random() * (screenHeight - padding * 2);
                            const randomX2 = padding + Math.random() * (screenWidth - padding * 2);
                            const randomY2 = padding + Math.random() * (screenHeight - padding * 2);
                            
                            createDroplet(randomX1, randomY1, newSize);
                            createDroplet(randomX2, randomY2, newSize);
                        }
                    }, 400);
                });
                
                document.body.appendChild(droplet);
                
                // Add entrance animation
                setTimeout(() => {
                    droplet.style.transform = 'scale(1)';
                }, 10);
            }
            
            // Function to create ripple effect
            function createRippleEffect(x, y) {
                const ripple = document.createElement('div');
                ripple.className = 'ripple';
                ripple.style.width = '80px';
                ripple.style.height = '80px';
                ripple.style.left = `${x - 40}px`;
                ripple.style.top = `${y - 40}px`;
                
                document.body.appendChild(ripple);
                
                // Remove ripple after animation completes
                setTimeout(() => {
                    ripple.remove();
                }, 800);
            }
            
            // Function to create splash particles
            function createSplashEffect(x, y) {
                const splashCount = 12; // Increased for more dramatic effect
                const splashDistance = 80; // Increased for wider splash
                
                for (let i = 0; i < splashCount; i++) {
                    const splash = document.createElement('div');
                    splash.className = 'splash';
                    
                    // Calculate position in a circle
                    const angle = (i / splashCount) * Math.PI * 2;
                    const splashX = x + Math.cos(angle) * (Math.random() * splashDistance);
                    const splashY = y + Math.sin(angle) * (Math.random() * splashDistance);
                    
                    splash.style.left = `${splashX}px`;
                    splash.style.top = `${splashY}px`;
                    
                    // Random size
                    const size = 3 + Math.random() * 5;
                    splash.style.width = `${size}px`;
                    splash.style.height = `${size}px`;
                    
                    document.body.appendChild(splash);
                    
                    // Animate the splash
                    const animationDuration = 300 + Math.random() * 500;
                    splash.animate([
                        { transform: 'translateY(0)', opacity: 1 },
                        { transform: `translateY(${20 + Math.random() * 30}px)`, opacity: 0 }
                    ], {
                        duration: animationDuration,
                        easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)'
                    });
                    
                    // Remove splash after animation
                    setTimeout(() => {
                        splash.remove();
                    }, animationDuration);
                }
            }
            
            // Function to create slicing effect
            function createSliceEffect(x, y, length, droplet) {
                // Create the slice line
                const slice = document.createElement('div');
                slice.className = 'slice-line';
                
                // Position at click point
                slice.style.left = `${x}px`;
                slice.style.top = `${y}px`;
                
                // Calculate angle based on mouse position relative to droplet center
                const rect = droplet.getBoundingClientRect();
                const dropletCenterX = rect.left + rect.width / 2;
                const dropletCenterY = rect.top + rect.height / 2;
                
                // Calculate angle for the slice
                const angle = Math.atan2(y - dropletCenterY, x - dropletCenterX) * 180 / Math.PI;
                slice.style.transform = `rotate(${angle}deg)`;
                
                document.body.appendChild(slice);
                
                // Remove slice after animation completes
                setTimeout(() => {
                    slice.remove();
                }, 300);
            }
            
            // Function to create droplet halves for slicing animation
            function createDropletHalves(rect, size) {
                // Create top half
                const topHalf = document.createElement('div');
                topHalf.className = 'droplet-half top-half';
                topHalf.style.width = `${rect.width}px`;
                topHalf.style.height = `${rect.height / 2}px`;
                topHalf.style.left = `${rect.left}px`;
                topHalf.style.top = `${rect.top}px`;
                
                // Create bottom half
                const bottomHalf = document.createElement('div');
                bottomHalf.className = 'droplet-half bottom-half';
                bottomHalf.style.width = `${rect.width}px`;
                bottomHalf.style.height = `${rect.height / 2}px`;
                bottomHalf.style.left = `${rect.left}px`;
                bottomHalf.style.top = `${rect.top + rect.height / 2}px`;
                
                // Add highlight effect to halves
                const highlight = document.createElement('div');
                highlight.style.position = 'absolute';
                highlight.style.top = '10%';
                highlight.style.left = '20%';
                highlight.style.width = '30%';
                highlight.style.height = '30%';
                highlight.style.backgroundColor = 'rgba(255, 255, 255, 0.4)';
                highlight.style.borderRadius = '50%';
                
                // Clone the highlight for bottom half
                const highlightClone = highlight.cloneNode(true);
                
                // Append highlights to halves
                topHalf.appendChild(highlight);
                bottomHalf.appendChild(highlightClone);
                
                // Add to document
                document.body.appendChild(topHalf);
                document.body.appendChild(bottomHalf);
                
                // Remove halves after animation completes
                setTimeout(() => {
                    topHalf.remove();
                    bottomHalf.remove();
                }, 400);
            }
        });
    </script>
</body>
</html>